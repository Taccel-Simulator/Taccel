import warp as wp
import warp.sparse as wps
import warp_ipc.collision_detection as collision_detection
from .sim_kernels import absolutize_arr_vec3d as absolutize_arr_vec3d, advection_x as advection_x, advection_y as advection_y, clamp_search_direction as clamp_search_direction, multiply_arr_vec3d_mul_scalar as multiply_arr_vec3d_mul_scalar, step_affine_y as step_affine_y, step_x as step_x, update_x_kernel as update_x_kernel
from _typeshed import Incomplete
from collections.abc import Callable as Callable
from warp.sim import Integrator
from warp.sim.model import Control as Control
from warp_ipc.sim_model import ASRModel as ASRModel
from warp_ipc.utils import MemoryProfiler as MemoryProfiler, Profiler as Profiler
from warp_ipc.utils.conjugate_gradient import conjugate_gradient as conjugate_gradient
from warp_ipc.utils.constants import AffineMaterialType as AffineMaterialType, ENV_STATE_INVALID as ENV_STATE_INVALID, ENV_STATE_NEWTON_SOLVED as ENV_STATE_NEWTON_SOLVED, ENV_STATE_VALID as ENV_STATE_VALID, MembraneType as MembraneType, VolMaterialType as VolMaterialType
from warp_ipc.utils.env_ops import reduce_env_energy_affine_body as reduce_env_energy_affine_body, reduce_env_energy_edge as reduce_env_energy_edge, reduce_env_energy_soft_shell as reduce_env_energy_soft_shell, reduce_env_energy_soft_tet as reduce_env_energy_soft_tet, reduce_env_energy_soft_vert as reduce_env_energy_soft_vert, reduce_env_energy_vert as reduce_env_energy_vert
from warp_ipc.utils.wp_math import bsr_warp_to_scipy as bsr_warp_to_scipy

class IPCIntegrator(Integrator):
    ENERGY_NAMES: Incomplete
    class ProfileStatistics:
        newton_iters: int
        dcd: int
        ccd: int
        grad: int
        hess: int
        linear_solver: int
        energy: int
        timestep_index: int
        newton_iter: int
        tiny_alpha: bool
        def __init__(self) -> None: ...
        @property
        def full_json(self): ...
        @property
        def current_timestep_data(self): ...
        @property
        def current_newton_iter_data(self): ...
        def record_iter_timer(self, timer: Profiler): ...
        def record_timestep_timer(self, timer: Profiler): ...
        def new_timestep(self) -> None: ...
        def new_newton_iter(self) -> None: ...
    temp_bsr_axpy_work_arrays: Incomplete
    stitch_stiffness: float
    stitch_damping: int
    device: Incomplete
    use_inversion_free_step_size_filter: bool
    use_hard_kinematic_constraint: bool
    tol: float
    invalid_tol_threshold: float
    tiny_alpha_as_invalid: bool
    maximum_newton_as_invalid: bool
    inversion_free_im_tol: float
    inversion_free_cubic_coef_tol: float
    max_newton_iter: int
    max_cg_iter: int
    cg_rel_tol: float
    time_int_rule: int
    dx_div_dv_scale_list: Incomplete
    soft_shell_membrane_type: Incomplete
    soft_vol_material_type: Incomplete
    affine_material_type: Incomplete
    total_iter: int
    max_iter: int
    use_cpu: bool
    profile_helper: Incomplete
    difftest_failed_handler: Callable[[IPCIntegrator], dict] | None
    raise_error: Incomplete
    robot_link_added: bool
    def __init__(self, device: str = 'cuda:0', raise_error: bool = False) -> None: ...
    def val_IP(self, model, dt: float, x: wp.array, y: wp.array, cdw: collision_detection.CollisionData, cdw_n: collision_detection.CollisionData, sm_damping: wps.BsrMatrix | None = None, enforce_reduce_each: bool = True, enable_inertia_energy: bool = True, enable_kinematic_constraint_energy: bool = True, enable_body_force_energy: bool = True, enable_rigidity_energy: bool = True, enable_cloth_elastic_energy: bool = True, enable_vol_elastic_energy: bool = True, enable_barrier_energy: bool = True, enable_friction_energy: bool = True, enable_damping_energy: bool = True) -> None: ...
    def grad_IP(self, model: ASRModel, dt: float, x: wp.array, y: wp.array, cdw: collision_detection.CollisionData, cdw_n: collision_detection.CollisionData, affine_gradient_y: wp.array, soft_gradient_x: wp.array, sm_damping: wps.BsrMatrix | None = None, enable_inertia_energy: bool = True, enable_kinematic_constraint_energy: bool = True, enable_body_force_energy: bool = True, enable_rigidity_energy: bool = True, enable_cloth_elastic_energy: bool = True, enable_vol_elastic_energy: bool = True, enable_barrier_energy: bool = True, enable_friction_energy: bool = True, enable_damping_energy: bool = True) -> None: ...
    def add_rigidity_hess(self, model: ASRModel, x: wp.array, y: wp.array, scale: float, project_pd: bool): ...
    def add_cloth_elastic_hess(self, model: ASRModel, x: wp.array, y: wp.array, scale: float, project_pd: bool): ...
    def add_vol_elastic_hess(self, model: ASRModel, x: wp.array, y: wp.array, scale: float, project_pd: bool): ...
    @property
    def dx_div_dv_scale(self): ...
    def get_hess_to_damp(self, model: ASRModel, dt: float, x: wp.array, y: wp.array, sm_damping: wps.BsrMatrix) -> None: ...
    def hess_IP(self, model: ASRModel, dt: float, x: wp.array, y: wp.array, cdw: collision_detection.CollisionData, cdw_n: collision_detection.CollisionData, sm: wps.BsrMatrix, sm_damping: wps.BsrMatrix | None = None, project_pd: bool = True, enable_inertia_energy: bool = True, enable_kinematic_constraint_energy: bool = True, enable_body_force_energy: bool = True, enable_rigidity_energy: bool = True, enable_cloth_elastic_energy: bool = True, enable_vol_elastic_energy: bool = True, enable_barrier_energy: bool = True, enable_friction_energy: bool = True, enable_damping_energy: bool = True) -> None: ...
    def clamp_search_direction(self, model: ASRModel, y: wp.array, direction: wp.array) -> None: ...
    def step_forward(self, model: ASRModel, x0: wp.array, y0: wp.array, x: wp.array, y: wp.array) -> None: ...
    def step_forward_with_consistent_alpha(self, model: ASRModel, x0: wp.array, y0: wp.array, x: wp.array, y: wp.array) -> None: ...
    def step_forward_with_alphas(self, model: ASRModel, x0: wp.array, y0: wp.array, x: wp.array, y: wp.array) -> None: ...
    def absolutize(self, model: ASRModel, x: wp.array) -> None: ...
    def check_grad(self, info: str, grad: wp.array, check_num: int = 8, check_start_index: int = 0) -> None: ...
    def diff_test(self, model: ASRModel, dt: float, x, y, cdw, cdw_n, direction_x: wp.array, sys_dir: wp.array, sm_damping: wps.BsrMatrix | None, energy_name: str, eps: float = 1e-07): ...
    def simulate(self, model: ASRModel, dt: float = None, control: Control = None): ...
    def advance_func(self, model: ASRModel, dt: float = 0.01, control: Control = None, enable_debug_check: bool = False) -> tuple[int, wp.array, wp.array]: ...
    def advection(self, model: ASRModel, dt, x, y) -> None: ...
    @property
    def last_step_time(self) -> float: ...
    def backward(self, model: ASRModel, dt: float, xn, vn, x, v, sm_damping: wps.BsrMatrix | None = None) -> None: ...
