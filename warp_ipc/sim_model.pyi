import numpy as np
import pyvista as pv
import torch
import trimesh as tm
import warp as wp
import warp.sparse as wps
from _typeshed import Incomplete
from functools import cached_property as cached_property
from numpy.typing import NDArray as NDArray
from scipy.sparse import bsr_matrix as bsr_matrix
from typing import Callable, Sequence
from warp.sim.model import Model, State
from warp_ipc.body_handle import BodyHandle as BodyHandle, TetMeshBodyHandle as TetMeshBodyHandle, TriMeshBodyHandle as TriMeshBodyHandle
from warp_ipc.energy import barrier_energy as barrier_energy, kinematic_constraint_energy as kinematic_constraint_energy
from warp_ipc.joint_handle import JointType as JointType, LocalJointHandle as LocalJointHandle, WorldJointHandle as WorldJointHandle
from warp_ipc.kinematic_kernels import check_is_satisfied_kernel as check_is_satisfied_kernel, project_system_kernel as project_system_kernel, update_dof_satisfied_kernel as update_dof_satisfied_kernel
from warp_ipc.linear_constraint_kernels import linear_constraint_project_system_kernel as linear_constraint_project_system_kernel
from warp_ipc.robots import Robot as Robot
from warp_ipc.set_state_kernels import set_sim_affine_state as set_sim_affine_state, set_sim_affine_vel as set_sim_affine_vel, set_sim_soft_state as set_sim_soft_state, set_sim_soft_vel as set_sim_soft_vel
from warp_ipc.sim_data import SimCacheDevice as SimCacheDevice
from warp_ipc.sim_kernels import affine_to_sys_grad as affine_to_sys_grad, init_affine_diag_hess_inds_kernel as init_affine_diag_hess_inds_kernel, init_affine_mass_matrix_kernel as init_affine_mass_matrix_kernel, init_soft_diag_hess_inds_kernel as init_soft_diag_hess_inds_kernel, initialize_soft_tilde_x as initialize_soft_tilde_x, initialize_tilde_y as initialize_tilde_y, negate_arr_vec12d as negate_arr_vec12d, negate_arr_vec3d as negate_arr_vec3d, safeguard_direction_x_kernel as safeguard_direction_x_kernel, soft_to_sys_grad as soft_to_sys_grad, sys_to_x_affine as sys_to_x_affine, sys_to_x_soft as sys_to_x_soft, update_x_kernel as update_x_kernel, y_to_x as y_to_x
from warp_ipc.utils.constants import BodyType as BodyType, ENV_STATE_NEWTON_SOLVED as ENV_STATE_NEWTON_SOLVED, ENV_STATE_VALID as ENV_STATE_VALID, MembraneType as MembraneType
from warp_ipc.utils.graph import collect_bending as collect_bending, collect_edge_and_point as collect_edge_and_point
from warp_ipc.utils.matrix import COOMatrix3x3 as COOMatrix3x3
from warp_ipc.utils.np_math import gauss_eliminate as gauss_eliminate, sparse_inv as sparse_inv
from warp_ipc.utils.wp_math import bsr_scipy_to_warp as bsr_scipy_to_warp
from warp_ipc.utils.wp_types import vec12d as vec12d

class ASRModel(Model):
    X: None
    particle_q: None
    surf_vi: None
    xt: None
    edge: None
    face: None
    tets: None
    soft_shell_IB: None
    soft_shell_E: None
    soft_shell_nu: None
    soft_shell_elem_vol: None
    soft_tet_E: None
    soft_tet_nu: None
    soft_tet_IB: None
    soft_tet_elem_vol: None
    arap_stretch_k: None
    arap_compression_k: None
    edge_stretching_stiffness: None
    bending: None
    bending_rest_angle: None
    bending_e: None
    bending_h: None
    bending_stiffness: None
    stitch: None
    stitch_map: None
    stitch_num_per_x: None
    hat_x: None
    particle_qd: None
    particle_qdd: None
    fn_x: None
    ft_x: None
    node_area: None
    edge_area: None
    node_xi: None
    edge_xi: None
    face_xi: None
    vol_body: None
    mass_body: None
    soft_tilde_x: None
    y: None
    hat_y: None
    v_y: None
    a_y: None
    tilde_y: None
    affine_ext_force_field: None
    affine_ext_y_force: None
    ABD_centers: None
    node2env: None
    edge2env: None
    face2env: None
    node2body: None
    face2body: None
    edge2body: None
    body_is_affine: None
    body_enable_self_collision: None
    body_env_id: None
    body_collision_layer: None
    collision_layer_filter: None
    env_states: None
    tet_envs: None
    affine_mass_matrix: None
    affine_is_closed: None
    affine_flipped: None
    affine_mass_xi: None
    affine_density: None
    soft_verts_mass: None
    half_space_n: None
    half_space_o: None
    half_space_mu: None
    hess_affine_diag: COOMatrix3x3
    hess_soft_diag: COOMatrix3x3
    hess_soft_shell_elastic: COOMatrix3x3
    hess_soft_bending_elastic: COOMatrix3x3
    hess_stitch: COOMatrix3x3
    hess_soft_vol_elastic: COOMatrix3x3
    hess_barrier: COOMatrix3x3
    hess_friction: COOMatrix3x3
    env_origins: None
    body_q: None
    body_qd: None
    @staticmethod
    def get_env_pos(num_envs: int, n_row: int, n_col: int, env_spacing: float, device: str = 'cuda:0') -> torch.tensor: ...
    @property
    def shape_count_sim(self) -> int: ...
    cdw: Incomplete
    cdw_n: Incomplete
    is_finalized: bool
    def finalize(self) -> None: ...
    @property
    def num_surf_verts(self): ...
    @property
    def num_body(self): ...
    @property
    def num_face(self): ...
    @property
    def num_edge(self): ...
    @property
    def num_x(self): ...
    @property
    def num_HS(self): ...
    @property
    def soft_shell_tris_num(self): ...
    @property
    def num_cloth_edges(self): ...
    @property
    def soft_vol_tets_num(self): ...
    @property
    def soft_verts_num(self): ...
    @property
    def soft_vol_body_offset(self) -> int: ...
    @property
    def dx_div_dv_scale(self): ...
    @property
    def soft_shell_elastic_connectivity_num(self) -> int: ...
    @property
    def soft_bending_connectivity_num(self) -> int: ...
    @property
    def soft_vol_elastic_connectivity_num(self) -> int: ...
    @property
    def soft_shell_elastic_connectivity_offset(self) -> int: ...
    @property
    def affine_body_num(self) -> int: ...
    @property
    def n_affine_dofs(self) -> int: ...
    @property
    def n_dofs(self) -> int: ...
    is_initialized: bool
    virtual_object_centers: wp.array
    particle_count: Incomplete
    particle_radius: Incomplete
    tri_count: Incomplete
    shape_count: Incomplete
    body_count: Incomplete
    body_name: Incomplete
    shape_body: Incomplete
    shape_geo_src: Incomplete
    shape_geo: Incomplete
    shape_transform: Incomplete
    shape_visible: Incomplete
    body_q_: Incomplete
    body_qd_: Incomplete
    def init(self) -> None: ...
    @cached_property
    def collision_map(self): ...
    def append_sim_data(self, attr: str, values: np.asarray, type) -> None: ...
    class KinematicConstraintHelper:
        model: Incomplete
        initial_stiffness: Incomplete
        def __init__(self, model: ASRModel, initial_stiffness: float = 10000.0) -> None: ...
        affine_has_constraint: wp.array
        soft_has_constraint: wp.array
        affine_target_transform: wp.array
        soft_target_dof: wp.array
        soft_dof_satisfied: wp.array
        affine_target_dof: wp.array
        affine_dof_satisfied: wp.array
        def init(self) -> None: ...
        def set_initial_stiffness(self, initial_stiffness: float = 10000.0): ...
        def initialize_stiffness(self) -> None: ...
        def increase_stiffness(self, factor: float = 2.0): ...
        def reset_dof_satisfied(self) -> None: ...
        def reset(self) -> None: ...
        def update_satisfied(self, x, y, dt: float, tol: float): ...
        def project_system(self, sm, sys_grad) -> None: ...
        def is_satisfied(self): ...
    class SetStateHelper:
        model: Incomplete
        def __init__(self, model: ASRModel) -> None: ...
        affine_update_state_mask: Incomplete
        affine_update_vel_mask: Incomplete
        affine_rotations: Incomplete
        affine_translations: Incomplete
        affine_linear_vel: Incomplete
        affine_angular_vel: Incomplete
        soft_update_state_mask: Incomplete
        soft_update_vel_mask: Incomplete
        soft_verts_positions: Incomplete
        soft_verts_vel: Incomplete
        def init(self) -> None: ...
        def clear_mask(self) -> None: ...
    class LinearConstraintHelper:
        model: ASRModel
        num_constraints: int
        constraint_matrix: np.array | None
        U_cpu: bsr_matrix | None
        Ut_cpu: bsr_matrix | None
        V_cpu: bsr_matrix | None
        U_device: wps.BsrMatrix | None
        Ut_device: wps.BsrMatrix | None
        V_device: wps.BsrMatrix | None
        affine_dof_env_id: wp.array | None
        def __init__(self, model: ASRModel) -> None: ...
        def init(self) -> None: ...
        def add_constraint(self, constraint_row: np.asarray): ...
        def add_constraints(self, constraint_rows: np.asarray): ...
        def finalize(self) -> None: ...
        def project_system(self, hess: wps.BsrMatrix, grad: wp.array): ...
    def allocate_sim_cache(self) -> None: ...
    device: Incomplete
    NUM_COLLISION_LAYERS: int
    num_envs: int
    elapsed_time: float
    frame: int
    viz_env: Incomplete
    viz: bool
    ground_plane_params: Incomplete
    handle_EE: bool
    dim: int
    epsv: float
    dhat: float
    kappa: float
    gravity: Incomplete
    dx_div_dv_scale_list: Incomplete
    k_elasticity_damping: float
    sim_data_type: Incomplete
    sim_data_host: Incomplete
    sim_cache: Incomplete
    E_body: Incomplete
    nu_body: Incomplete
    mu_body: Incomplete
    soft_shell_membrane_type: Incomplete
    affine_verts_num: int
    soft_shell_body_num: int
    soft_vol_body_num: int
    soft_body_types: Incomplete
    xi_body: Incomplete
    affine_tris_num: int
    affine_body_handles: list[TriMeshBodyHandle]
    soft_body_handles: list[TriMeshBodyHandle]
    soft_tri_elem_offsets: Incomplete
    soft_stretching_edge_offsets: Incomplete
    soft_tet_elem_offsets: Incomplete
    robots: list[Robot]
    constraint_fns: list[Callable]
    max_collisions: Incomplete
    kinematic_helper: Incomplete
    set_state_helper: Incomplete
    linear_constraint_helper: Incomplete
    time_int_rule: int
    affine_body_handles_viz: list[TriMeshBodyHandle]
    soft_body_handles_viz: list[TetMeshBodyHandle]
    def __init__(self, num_envs: int = 1, viz_envs: list[int] = [], device: str = 'cuda:0') -> None: ...
    @property
    def dummy_robot(self) -> Robot | None: ...
    def add_plane(self, n, o, mu) -> None: ...
    def add_soft_shell_body(self, mesh, edge_stretching_stiffness: float = 0, density: float = 1000, E: float = 0, nu: float = 0.3, compression_softening: float = 0, bending_stiffness: float = 0, mu: float = 0, xi: float = 0.001, mass_thickness: float | None = None, env_id: int = 0) -> TriMeshBodyHandle: ...
    def add_garment_stitch(self, stitches) -> None: ...
    def add_soft_vol_body(self, mesh: pv.UnstructuredGrid, density: float, E: float, nu: float, mu: float, env_id: int = 0, coll_layer: int = 0, self_coll: bool = True) -> TetMeshBodyHandle: ...
    def add_affine_body(self, x, face, density, E, mu, mass_xi: None | float = None, env_id: int = 0, nu: float = 0.3) -> TriMeshBodyHandle: ...
    def add_world_revolute_joint(self, handle: BodyHandle, local_axis_position: NDArray, axis_direction: NDArray) -> WorldJointHandle: ...
    def add_world_prismatic_joint(self, handle: BodyHandle, axis: NDArray) -> WorldJointHandle: ...
    def add_fix_point_constraint(self, parent_handle: BodyHandle, child_handle: BodyHandle, fix_point_location: torch.Tensor | Sequence[float]): ...
    def add_local_revolute_joint(self, parent_handle: BodyHandle, child_handle: BodyHandle, joint_origin_transform: NDArray, joint_axis: NDArray) -> LocalJointHandle: ...
    @property
    def tac_handles(self) -> list[list[TetMeshBodyHandle]]: ...
    robot_link_added: bool
    def add_robot(self, urdf_path: str, env_id: int = 0, start_coll_layer: int = 2, coll_layers: list[int] = [], disable_coll_layers: list[int] = [], mu: float = 0.3, self_collision: bool = False, **kwargs): ...
    def set_robot_states(self, joint_params: list[dict[str, float]] | NDArray | torch.Tensor, root_tf: NDArray | torch.Tensor | None = None, env_ids: list[int] = []): ...
    def set_robot_targets(self, joint_params: list[dict[str, float]] | NDArray | torch.Tensor, root_tf: NDArray | torch.Tensor | None = None, env_ids: list[int] = []): ...
    def set_affine_kinematic_target(self, handle: BodyHandle, target_rot_mat: NDArray | torch.Tensor, target_translation: NDArray | torch.Tensor) -> None: ...
    def set_soft_kinematic_constraint(self, handle: BodyHandle, verts_mask: NDArray | torch.Tensor) -> None: ...
    def set_soft_kinematic_target(self, handle: BodyHandle, target_verts: NDArray | torch.Tensor) -> None: ...
    def get_body_x(self, handle: BodyHandle) -> torch.Tensor: ...
    def get_body_face(self, handle: BodyHandle) -> torch.Tensor: ...
    def get_body_mesh(self, handle: BodyHandle): ...
    def write_target_scene(self, filename: str) -> None: ...
    def get_body_x_target(self, handle: BodyHandle) -> torch.Tensor: ...
    def get_body_target_mesh(self, handle: BodyHandle): ...
    def get_scene_mesh(self) -> tm.Trimesh: ...
    def get_target_scene_mesh(self) -> tm.Trimesh: ...
    def write_scene(self, filename: str, divide: bool = False, double_face: bool = False) -> None: ...
    def get_element_by_handle(self, handle: TetMeshBodyHandle, return_numpy: bool = True) -> tuple[NDArray, NDArray]: ...
    def get_soft_verts_from_handle(self, handle: BodyHandle) -> NDArray: ...
    def get_soft_surf_verts_from_handle(self, handle: BodyHandle) -> NDArray: ...
    def get_soft_body_mesh_from_handle(self, handle: TetMeshBodyHandle) -> tm.Trimesh: ...
    def get_soft_body_meshes_from_handle(self, handles: list[TetMeshBodyHandle], concat: bool = True) -> list[tm.Trimesh] | tm.Trimesh: ...
    def get_affine_body_mesh_from_handle(self, handle: TriMeshBodyHandle) -> tm.Trimesh: ...
    def get_soft_body_from_handle(self, handle: TetMeshBodyHandle) -> pv.UnstructuredGrid: ...
    def get_soft_nodes_from_idxs(self, idxs: list[tuple[int, int]]) -> NDArray: ...
    def get_affine_body_wp_meshes_from_handle(self, handles: list[TriMeshBodyHandle]) -> list[wp.sim.Mesh]: ...
    def get_affine_body_meshes_from_handle(self, handles: list[TriMeshBodyHandle], concat: bool = True) -> list[tm.Trimesh] | tm.Trimesh: ...
    def initialize_tilde_x_y(self, dt: float) -> None: ...
    def initialize_tilde_x_y_adjoint(self, dt: float) -> None: ...
    def initialize_hat_x_y(self) -> None: ...
    def enable_affine_kinematic_constraint(self, handle: BodyHandle) -> None: ...
    def disable_affine_kinematic_constraint(self, handle: BodyHandle) -> None: ...
    @property
    def x_target(self) -> torch.Tensor: ...
    @property
    def soft_kinematic_constraint(self) -> torch.Tensor: ...
    @property
    def soft_kinematic_target(self) -> torch.Tensor: ...
    def set_kinematic_stiffness(self, weight) -> None: ...
    def set_affine_state(self, handle: BodyHandle, rotation: NDArray | torch.Tensor, translation: NDArray | torch.Tensor) -> None: ...
    def set_soft_state(self, handle: BodyHandle, positions: NDArray | torch.Tensor) -> None: ...
    def apply_set_state(self, x: Incomplete | None = None, y: Incomplete | None = None) -> None: ...
    def set_body_self_collision(self, handle: BodyHandle, to_enable: bool) -> None: ...
    def set_body_env_id(self, handle: BodyHandle, env_id: int) -> None: ...
    def get_body_env_id(self, handle: BodyHandle) -> int: ...
    def set_body_collision_layer(self, handle: BodyHandle, layer_index: int) -> None: ...
    def set_collision_layer_filter(self, layer_i: int, layer_j: int, to_enable_collision: bool) -> None: ...
    def get_joint_value(self, joint_handle: WorldJointHandle) -> float: ...
    def get_soft_body_pos(self, body_handle: BodyHandle, return_numpy: bool = True) -> NDArray: ...
    def get_affine_body_state(self, body_handle: BodyHandle, return_numpy: bool = True) -> tuple[NDArray, NDArray]: ...
    def get_affine_body_state_matrix(self, body_handle: BodyHandle, return_numpy: bool = True) -> NDArray: ...
    def get_affine_body_velocity(self, body_handle: BodyHandle, return_numpy: bool = True) -> tuple[NDArray, NDArray]: ...
    def get_soft_body_velocity(self, body_handle: BodyHandle, return_numpy: bool = True) -> NDArray: ...
    def get_affine_body_velocity_matrix(self, body_handle: BodyHandle, return_numpy: bool = True) -> NDArray: ...
    def get_environment_states(self): ...
    def check_initial_state_valid(self, exclude_self_collision: bool = False) -> bool: ...
    def reset_environement(self, env_id) -> None: ...
    def save_sim_x_to_xt(self) -> None: ...
    def y_to_x(self, direction: wp.array, direction_x: wp.array) -> None: ...
    def sys_to_x(self, sys_direction: wp.array, direction_x: wp.array) -> None: ...
    def merge_sys_grad(self) -> None: ...
    def negate_vec3d(self, gradient: wp.array) -> None: ...
    def negate_vec12d(self, gradient: wp.array) -> None: ...
    def negate(self, gradient: wp.array) -> None: ...
    def safeguard_direction_x(self, direction_x: wp.array) -> None: ...
    def check_initial_state_valid(self, exclude_self_collision: bool = False) -> bool: ...
    def step(self, dt) -> None: ...
    def requires_grad(self, flag: bool = True) -> None: ...
    def clear_grad(self) -> None: ...
    def state(self, requires_grad: Incomplete | None = None) -> State: ...
    def update_contact_force(self, dt: float) -> torch.Tensor: ...
    def get_body_nodal_contact_force(self, handle: BodyHandle, dt: float) -> torch.Tensor: ...
    def get_body_nodal_collision_force(self, handle: BodyHandle, dt: float) -> torch.Tensor: ...
    def get_body_nodal_friction_force(self, handle: BodyHandle, dt: float) -> torch.Tensor: ...
    def get_body_resultant_contact_force(self, handle: BodyHandle, dt: float) -> torch.Tensor: ...
    def set_affine_external_force_field(self, handle: BodyHandle, target_force_acceleration: NDArray | torch.Tensor) -> None: ...
    def set_affine_external_torque(self, handle: BodyHandle, torque: NDArray | torch.Tensor = ...) -> None: ...
    def set_affine_external_wrench(self, handle: BodyHandle, target_force_acceleration: NDArray | torch.Tensor, torque: NDArray | torch.Tensor = ...) -> None: ...
    def clear_force(self) -> None: ...
